input [0:127]   aes_data_out,
reg [0:31] pkt_ks_shifter;
output reg [ 5:0] pkt_keystream

always @(posedge clk or negedge rstn)
    if(!rstn)
        pkt_ks_buf <= '0;
    else if(pkt_ks_buf_load)
        pkt_ks_buf <= aes_data_out;

   // load keystream when it is empty and shifter has data
wire shift_pkt_ks = !pkt_ks_vld && pkt_ks_shift_size;

wire [1:0] pkt_buf_sel = 3'd4-pkt_ks_buf_size;

always @(posedge clk or negedge rstn)
    if(!rstn)
        pkt_ks_shifter <= '0;
    else if(load_pkt_shift)
        pkt_ks_shifter <= pkt_ks_buf[pkt_buf_sel];
    else if(shift_pkt_ks)
        pkt_ks_shifter <= pkt_ks_shifter << 1;

always @(posedge clk or negedge rstn)
    if(!rstn)
        pkt_keystream <= '0;
    else if(pkt_start || pkt_done || rd_ks) 
        pkt_keystream <= '0;
    else if(shift_pkt_ks)
        pkt_keystream <= pkt_keystream << 1 | pkt_ks_shifter[0];

    input   [5:0]      phy_tx_bits_i,        // 
    output  [2:0]      ecu_txbit_sig1_r_o,   // 
    output  [2:0]      ecu_txbit_sig2_r_o,   // 
    input   [1:0]      txbits_per_symbol_i,  // 

assign ecu_txbit_sig1_r_o = phy_tx_bits_i[2:0] ^ pkt_keystream_i[2:0];
assign ecu_txbit_sig2_r_o = phy_tx_bits_i[5:3] ^
                                pkt_keystream_i >> txbits_per_symbol_i;


#######################################################


    else if(pkt_ks_buf_load)
        pkt_ks_buf <= aes_data_out;
    else if(load_pkt_shift)
        pkt_ks_shifter <= pkt_ks_buf[pkt_buf_sel];
    else if(shift_pkt_ks)
        pkt_ks_shifter <= pkt_ks_shifter << 1;

#######################################################
Solution 

// ---------------------- declarations ----------------------
reg [127:0] aes_data_buf;
reg [31:0]  pkt_ks_shifter;
reg [5:0]   pkt_keystream;
reg [5:0]   bit_count;
reg [1:0]   word_idx;
reg [2:0]   words_rem;

// ---------------------- sequential logic ------------------
always @(posedge clk or negedge rstn) begin
  if (!rstn) begin
    aes_data_buf  <= 128'd0;
    pkt_ks_shifter <= 32'd0;
    pkt_keystream <= 6'd0;
    bit_count     <= 6'd0;
    word_idx      <= 2'd0;
    words_rem     <= 3'd0;
  end else begin
    // Example: load new block when your model updates
    if (pkt_ks_buf_load) begin
      aes_data_buf  <= aes_data_out;  // latch model output
      word_idx      <= 2'd0;
      words_rem     <= 3'd4;          // 4 words of 32 bits
      bit_count     <= 6'd0;
    end

    // Shift when enabled
    if (shift_pkt_ks) begin
      // If shifter empty but words remain, reload 32 bits
      if (bit_count == 0 && words_rem != 0) begin
        pkt_ks_shifter <= aes_data_buf >> (word_idx*32);
        word_idx       <= word_idx + 1;
        words_rem      <= words_rem - 1;
        bit_count      <= 6'd32;
      end

      // If shifter has bits, drain LSB-first
      if (bit_count != 0) begin
        pkt_keystream  <= {pkt_keystream[4:0], pkt_ks_shifter[0]};
        pkt_ks_shifter <= pkt_ks_shifter >> 1;
        bit_count      <= bit_count - 1;
      end
    end

    // Optional clear conditions
    if (pkt_start || pkt_done || rd_ks) begin
      pkt_keystream <= 6'd0;
    end
  end
end



// XOR keystream with PHY bits (Verilog-2001 friendly; no variable part-selects)

// Inputs (assumed driven elsewhere):
//   input  [5:0] phy_tx_bits_i;
//   input  [5:0] pkt_keystream;        // rolling 6-bit window, LSB-first
//   input  [1:0] txbits_per_symbol_i;  // 1..3 (how many bits consumed for 1st symbol)
// Outputs:
//   output [2:0] ecu_txbit_sig1_r_o;
//   output [2:0] ecu_txbit_sig2_r_o;

wire [5:0] ks6        = pkt_keystream;
wire [2:0] ks_lo3     = ks6[2:0];                                // first 3 bits
wire [5:0] ks_shifted = (ks6 >> txbits_per_symbol_i);            // advance by symbol size
wire [2:0] ks_nxt3    = ks_shifted[2:0];                         // next 3 bits after advance

assign ecu_txbit_sig1_r_o = phy_tx_bits_i[2:0] ^ ks_lo3;
assign ecu_txbit_sig2_r_o = phy_tx_bits_i[5:3] ^ ks_nxt3;

/*
// --- If your pkt_keystream is MSB-first (bit 5 oldest), use this instead ---

wire [5:0] ks6        = pkt_keystream;
wire [2:0] ks_hi3     = ks6[5:3];                                // first 3 MSBs
wire [5:0] ks_shifted = (ks6 << txbits_per_symbol_i);            // advance toward MSB
wire [2:0] ks_nxt3    = ks_shifted[5:3];                         // next 3 MSBs after advance

assign ecu_txbit_sig1_r_o = phy_tx_bits_i[2:0] ^ ks_hi3;
assign ecu_txbit_sig2_r_o = phy_tx_bits_i[5:3] ^ ks_nxt3;










   






