input [0:127]   aes_data_out,
reg [0:31] pkt_ks_shifter;
output reg [ 5:0] pkt_keystream

always @(posedge clk or negedge rstn)
    if(!rstn)
        pkt_ks_buf <= '0;
    else if(pkt_ks_buf_load)
        pkt_ks_buf <= aes_data_out;

   // load keystream when it is empty and shifter has data
wire shift_pkt_ks = !pkt_ks_vld && pkt_ks_shift_size;

wire [1:0] pkt_buf_sel = 3'd4-pkt_ks_buf_size;

always @(posedge clk or negedge rstn)
    if(!rstn)
        pkt_ks_shifter <= '0;
    else if(load_pkt_shift)
        pkt_ks_shifter <= pkt_ks_buf[pkt_buf_sel];
    else if(shift_pkt_ks)
        pkt_ks_shifter <= pkt_ks_shifter << 1;

always @(posedge clk or negedge rstn)
    if(!rstn)
        pkt_keystream <= '0;
    else if(pkt_start || pkt_done || rd_ks) 
        pkt_keystream <= '0;
    else if(shift_pkt_ks)
        pkt_keystream <= pkt_keystream << 1 | pkt_ks_shifter[0];

    input   [5:0]      phy_tx_bits_i,        // 
    output  [2:0]      ecu_txbit_sig1_r_o,   // 
    output  [2:0]      ecu_txbit_sig2_r_o,   // 
    input   [1:0]      txbits_per_symbol_i,  // 

assign ecu_txbit_sig1_r_o = phy_tx_bits_i[2:0] ^ pkt_keystream_i[2:0];
assign ecu_txbit_sig2_r_o = phy_tx_bits_i[5:3] ^
                                pkt_keystream_i >> txbits_per_symbol_i;


#######################################################


    else if(pkt_ks_buf_load)
        pkt_ks_buf <= aes_data_out;
    else if(load_pkt_shift)
        pkt_ks_shifter <= pkt_ks_buf[pkt_buf_sel];
    else if(shift_pkt_ks)
        pkt_ks_shifter <= pkt_ks_shifter << 1;

#######################################################
Solution 

// ---------------------- declarations ----------------------
reg [127:0] aes_data_buf;
reg [31:0]  pkt_ks_shifter;
reg [5:0]   pkt_keystream;
reg [5:0]   bit_count;
reg [1:0]   word_idx;
reg [2:0]   words_rem;

// ---------------------- sequential logic ------------------
always @(posedge clk or negedge rstn) begin
  if (!rstn) begin
    aes_data_buf  <= 128'd0;
    pkt_ks_shifter <= 32'd0;
    pkt_keystream <= 6'd0;
    bit_count     <= 6'd0;
    word_idx      <= 2'd0;
    words_rem     <= 3'd0;
  end else begin
    // Example: load new block when your model updates
    if (pkt_ks_buf_load) begin
      aes_data_buf  <= aes_data_out;  // latch model output
      word_idx      <= 2'd0;
      words_rem     <= 3'd4;          // 4 words of 32 bits
      bit_count     <= 6'd0;
    end

    // Shift when enabled
    if (shift_pkt_ks) begin
      // If shifter empty but words remain, reload 32 bits
      if (bit_count == 0 && words_rem != 0) begin
        pkt_ks_shifter <= aes_data_buf >> (word_idx*32);
        word_idx       <= word_idx + 1;
        words_rem      <= words_rem - 1;
        bit_count      <= 6'd32;
      end

      // If shifter has bits, drain LSB-first
      if (bit_count != 0) begin
        pkt_keystream  <= {pkt_keystream[4:0], pkt_ks_shifter[0]};
        pkt_ks_shifter <= pkt_ks_shifter >> 1;
        bit_count      <= bit_count - 1;
      end
    end

    // Optional clear conditions
    if (pkt_start || pkt_done || rd_ks) begin
      pkt_keystream <= 6'd0;
    end
  end
end



// XOR keystream with PHY bits (Verilog-2001 friendly; no variable part-selects)

// Inputs (assumed driven elsewhere):
//   input  [5:0] phy_tx_bits_i;
//   input  [5:0] pkt_keystream;        // rolling 6-bit window, LSB-first
//   input  [1:0] txbits_per_symbol_i;  // 1..3 (how many bits consumed for 1st symbol)
// Outputs:
//   output [2:0] ecu_txbit_sig1_r_o;
//   output [2:0] ecu_txbit_sig2_r_o;

wire [5:0] ks6        = pkt_keystream;
wire [2:0] ks_lo3     = ks6[2:0];                                // first 3 bits
wire [5:0] ks_shifted = (ks6 >> txbits_per_symbol_i);            // advance by symbol size
wire [2:0] ks_nxt3    = ks_shifted[2:0];                         // next 3 bits after advance

assign ecu_txbit_sig1_r_o = phy_tx_bits_i[2:0] ^ ks_lo3;
assign ecu_txbit_sig2_r_o = phy_tx_bits_i[5:3] ^ ks_nxt3;

/*
// --- If your pkt_keystream is MSB-first (bit 5 oldest), use this instead ---

wire [5:0] ks6        = pkt_keystream;
wire [2:0] ks_hi3     = ks6[5:3];                                // first 3 MSBs
wire [5:0] ks_shifted = (ks6 << txbits_per_symbol_i);            // advance toward MSB
wire [2:0] ks_nxt3    = ks_shifted[5:3];                         // next 3 MSBs after advance

assign ecu_txbit_sig1_r_o = phy_tx_bits_i[2:0] ^ ks_hi3;
assign ecu_txbit_sig2_r_o = phy_tx_bits_i[5:3] ^ ks_nxt3;

phy_tx_bits_i [5:0]
txbits_per_symbol_i [1:0]



*****************************************

always @(posedge clk or negedge rstn)
    if(!rstn)
        enc_pkt <= 1'b0;
    else if(pkt_start)
        enc_pkt <= pkt_enc_en;

assign pkt_enc = enc_pkt && pkt_key_rdy && 
                    pkt_ks_buf_empty && !pkt_ks_buf_load;

////////////////////////////////////////////////////////////////

always @(posedge clk or negedge rstn)                                           
    if(!rstn) begin                                                             
        pkt_ctr <= '0;                                                          
    end else if(pkt_start) begin                                                
        pkt_ctr <= '0;                                                          
    end else if(pkt_ks_buf_load) begin                                          
        pkt_ctr <= pkt_ctr + 1'b1;                                              
    end

/*//////////////////////////////////////////////////////////////
  128-bit keystream buffer

  We need to buffer output as packet and stream encryption
  share the same AES block. While the AES block will hold
  its output data constant, we need to save it so the AES block
  can be used for stream encryption.
*/
reg [0:3][31:0] pkt_ks_buf;
reg [2:0]       pkt_ks_buf_size; // size in 32-bit words (0-4)
wire            load_pkt_shift;

always @(posedge clk or negedge rstn)
    if(!rstn)
        pkt_ks_buf_size <= 3'd0;
    else if(pkt_start || pkt_done)
        pkt_ks_buf_size <= 3'd0;
    else if(pkt_ks_buf_load)
        pkt_ks_buf_size <= 3'd4;
    else if(load_pkt_shift)
        pkt_ks_buf_size <= pkt_ks_buf_size - 1'b1;

assign pkt_ks_buf_empty = !pkt_ks_buf_size;

always @(posedge clk or negedge rstn)
    if(!rstn)
        pkt_ks_buf <= '0;
    else if(pkt_ks_buf_load)
        pkt_ks_buf <= aes_data_out;

////////////////////////////////////////////////////////////////

// We need a small buffer to use while the next keystream is being computed.
// We can't use the same 128-bit output buffer as we need that to be empty
// when computation is done to free up AES block for stream encryption,
// otherwise we would have to stall the AES block and wait until the buffer 
// is empty before we could start another stream encryption operation.

// Since bits per symbol may be 1, 2, 3, 4, 6, we need to merge
// data across buffers. 
// Implement the small buffer as a shifter. 
// This simplifies the merge operation.
reg [0:31] pkt_ks_shifter;
reg [5:0]  pkt_ks_shift_size;

// load shifter when it is empty and buffer has data
assign load_pkt_shift = pkt_ks_buf_size && !pkt_ks_shift_size;

// load keystream when it is empty and shifter has data
wire shift_pkt_ks = !pkt_ks_vld && pkt_ks_shift_size;

always @(posedge clk or negedge rstn)
    if(!rstn)
        pkt_ks_shift_size <= 6'd0;
    else if(pkt_start || pkt_done) 
        pkt_ks_shift_size <= 6'd0;
    else if(load_pkt_shift)
        pkt_ks_shift_size <= 6'd32;
    else if(shift_pkt_ks)
        pkt_ks_shift_size <= pkt_ks_shift_size - 1'b1;

wire [1:0] pkt_buf_sel = 3'd4-pkt_ks_buf_size;

always @(posedge clk or negedge rstn)
    if(!rstn)
        pkt_ks_shifter <= '0;
    else if(load_pkt_shift)
        pkt_ks_shifter <= pkt_ks_buf[pkt_buf_sel];
    else if(shift_pkt_ks)
        pkt_ks_shifter <= pkt_ks_shifter << 1;

////////////////////////////////////////////////////////////////
// packet keystream output

wire rd_ks;
reg [2:0]  pkt_ks_size;
always @(posedge clk or negedge rstn)
    if(!rstn)
        pkt_ks_size <= 5'd0;
    else if(pkt_start || pkt_done || rd_ks) 
        pkt_ks_size <= 5'd0;
    else if(shift_pkt_ks)
        pkt_ks_size <= pkt_ks_size + 1'b1;

always @(posedge clk or negedge rstn)
    if(!rstn)
        pkt_keystream <= '0;
    else if(pkt_start || pkt_done || rd_ks) 
        pkt_keystream <= '0;
    else if(shift_pkt_ks)
        pkt_keystream <= pkt_keystream << 1 | pkt_ks_shifter[0];

assign pkt_ks_vld = pkt_ks_size >= bits_per_symbol;



*********************************************************************************************
Final soln 
*********************************************************************************************

// ====================================================================
// Testbench logic to generate pkt_keystream from aes_data_out
// ====================================================================

// Inputs in TB
reg         clk, rstn;
reg  [127:0] aes_data_out;      // driven by your AES model
reg          pkt_start, pkt_done, pkt_ks_buf_load, pkt_ks_vld, rd_ks;

// Internal regs
reg  [0:3][31:0] tb_pkt_ks_buf;
reg  [2:0]       tb_pkt_ks_buf_size;
reg  [0:31]      tb_pkt_ks_shifter;
reg  [5:0]       tb_pkt_ks_shift_size;
reg  [5:0]       pkt_keystream;   // <-- this is what you want

// Controls
wire       tb_load_pkt_shift = tb_pkt_ks_buf_size && !tb_pkt_ks_shift_size;
wire       tb_shift_pkt_ks   = !pkt_ks_vld && tb_pkt_ks_shift_size;
wire [1:0] tb_pkt_buf_sel    = 3'd4 - tb_pkt_ks_buf_size;

// Sequential logic
always @(posedge clk or negedge rstn) begin
  if (!rstn) begin
    tb_pkt_ks_buf       <= '0;
    tb_pkt_ks_buf_size  <= 3'd0;
    tb_pkt_ks_shifter   <= '0;
    tb_pkt_ks_shift_size<= 6'd0;
    pkt_keystream       <= 6'd0;
  end else begin
    // Capture new AES block into 128-bit buffer
    if (pkt_ks_buf_load) begin
      tb_pkt_ks_buf      <= aes_data_out;
      tb_pkt_ks_buf_size <= 3'd4;
    end else if (tb_load_pkt_shift) begin
      tb_pkt_ks_buf_size <= tb_pkt_ks_buf_size - 1'b1;
    end

    // Shifter load/shift
    if (tb_load_pkt_shift) begin
      tb_pkt_ks_shifter    <= tb_pkt_ks_buf[tb_pkt_buf_sel];
      tb_pkt_ks_shift_size <= 6'd32;
    end else if (tb_shift_pkt_ks) begin
      tb_pkt_ks_shifter    <= tb_pkt_ks_shifter << 1;       // MSB-first
      tb_pkt_ks_shift_size <= tb_pkt_ks_shift_size - 1'b1;
    end

    // 6-bit rolling keystream window
    if (pkt_start || pkt_done || rd_ks) begin
      pkt_keystream <= 6'd0;
    end else if (tb_shift_pkt_ks) begin
      pkt_keystream <= (pkt_keystream << 1) | tb_pkt_ks_shifter[0];
    end
  end
end









   






